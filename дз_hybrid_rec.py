# -*- coding: utf-8 -*-
"""ДЗ_hybrid_rec.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17BAMZi_E87XBqElgI4Wh_pL4_PqkpHg3
"""

!pip install surprise

from surprise import SVD, SVDpp
from surprise import Dataset
from surprise import accuracy
from surprise import Reader
from surprise.model_selection import train_test_split

import matplotlib.pyplot as plt

from tqdm import tqdm_notebook

from sklearn.feature_extraction.text import TfidfTransformer, CountVectorizer
from sklearn.neighbors import NearestNeighbors

import pandas as pd
import numpy as np

!wget 'https://drive.google.com/uc?id=1m0rwReR09achL0xTM6QPoN4tykz5bOMx' -O MovieLens.zip

!unzip MovieLens.zip

links = pd.read_csv('links.csv')
movies = pd.read_csv('movies.csv')
ratings = pd.read_csv('ratings.csv')
tags = pd.read_csv('tags.csv')

dataset = pd.DataFrame({
    'uid': movies_with_ratings.userId,
    'iid': movies_with_ratings.title,
    'rating': movies_with_ratings.rating
})

reader = Reader(rating_scale=(0.5, 5.0))
data = Dataset.load_from_df(dataset, reader)

trainset, testset = train_test_split(data, test_size=.15, random_state=42)

algo = SVD(n_factors=20, n_epochs=20)
algo.fit(trainset)

results_rating_mean = ratings.copy()

results_rating_mean['rating_median'] = results_rating_mean.groupby('movieId')['rating'].transform('median').round(1)
results_rating_mean.head()

movies_with_ratings = movies.join(results_rating_mean.set_index('movieId'), on='movieId').reset_index(drop=True)
movies_with_ratings.dropna(inplace=True)

movies_with_ratings.head()

def change_string(s):
    return ' '.join(s.replace(' ', '').replace('-', '').split('|'))

movie_genres = [change_string(g) for g in movies.genres.values]

count_vect = CountVectorizer()
X_train_counts = count_vect.fit_transform(movie_genres)

tfidf_transformer = TfidfTransformer()
X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)

neigh = NearestNeighbors(n_neighbors=20, n_jobs=-1, metric='euclidean')
neigh.fit(X_train_tfidf)

title_genres = {}

for index, row in tqdm_notebook(movies.iterrows()):
    title_genres[row.title] = row.genres

title_genres

def recommend_for_user(user_id):
    current_user_id = user_id
    user_movies = movies_with_ratings[movies_with_ratings.userId == current_user_id].title.unique()

    last_user_movie = user_movies[-1]

    movie_genres = title_genres[last_user_movie]

    movie_genres = change_string(movie_genres)

    predict = count_vect.transform([movie_genres])
    X_tfidf2 = tfidf_transformer.transform(predict)

    res = neigh.kneighbors(X_tfidf2, return_distance=True)

    movies_to_score = movies.iloc[res[1][0]].title.values

    scores = []
    titles = []

    for movie in movies_to_score:
        if movie in user_movies:
            continue

        scores.append(algo.predict(uid=current_user_id, iid=movie).est)
        titles.append(movie)


    best_indexes = np.argsort(scores)[-10:]
    for i in reversed(best_indexes):
        print(titles[i], scores[i])

movies_with_ratings.head()

def recommend_for_user1(user_id):
    current_user_id = user_id
    user_movies = movies_with_ratings[movies_with_ratings.userId == current_user_id].title.unique()

    last_user_movie = user_movies[-1]

    movie_genres = title_genres[last_user_movie]

    movie_genres = change_string(movie_genres)

    predict = count_vect.transform([movie_genres])
    X_tfidf2 = tfidf_transformer.transform(predict)

    res = neigh.kneighbors(X_tfidf2, return_distance=True)

    movies_to_score = movies.iloc[res[1][0]].title.values

    scores = []
    titles = []



    for movie in movies_to_score:
        if movie in user_movies:
            continue

        scores.append(algo.predict(uid=current_user_id, iid=movie).est)
        titles.append(movie)


    best_indexes = np.argsort(scores)[-20:] # возьмем 20 рекомендуемых фильмов

    userss = [] # Создаем пустой список для пользователей
    # Найдем пользователей которые смотрели рекомендуемые фильмы и поставили оценку = 5 среди фильмов с рейтингом выше 3,5.
    for i in reversed(best_indexes):

        userst = (movies_with_ratings[(movies_with_ratings.title == titles[i])&(movies_with_ratings.rating_median > 3.5 )&(movies_with_ratings.rating == 5)])

        userss = userss + list(userst['userId'].values)
    # Среди найденых пользователей оставим только тех кому понравилдись 2 и  более из предложенных фильмов
    list_1 = []
    for user in userss:
        d = userss.count(user)
        if d > 1:
            list_1.append(user)
    users_list = set(list_1)


    scores1 = []
    titles1 = []


    # для отобранных пользователей сформируем рекомендации
    for user in users_list:

        current_user_id1 = user

        user_movies1 = movies_with_ratings[movies_with_ratings.userId == current_user_id1].title.unique()

        last_user_movie1 = user_movies1[-1]

        movie_genres1 = title_genres[last_user_movie1]

        movie_genres1 = change_string(movie_genres1)

        predict = count_vect.transform([movie_genres1])
        X_tfidf3 = tfidf_transformer.transform(predict)

        res = neigh.kneighbors(X_tfidf3, return_distance=True)

        movies_to_score1 = movies.iloc[res[1][0]].title.values



        for movie in movies_to_score1:

            if movie in user_movies: # учитываем фильмы которые не смотрел первый пользователь
                continue

            elif movie not in  titles1:
                scores1.append(algo.predict(uid=current_user_id1, iid=movie).est)
                titles1.append(movie)




    best_indexes1 = np.argsort(scores1)[-10:]
    for i in reversed(best_indexes1):

        print(titles1[i])

recommend_for_user1(2.0) # Новая рекомендация

recommend_for_user(2.0)# Старая рекомендация



