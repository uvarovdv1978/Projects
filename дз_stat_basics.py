# -*- coding: utf-8 -*-
"""ДЗ_stat_basics

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zYlYPTNn-Z_poppli99s-xm-16KbZt-n

# Базовые понятия статистики

Булыгин Олег:  
* [LinkedIn](linkedin.com/in/obulygin)  
* [Telegram](https://t.me/obulygin91)  
* [Vk](vk.com/obulygin91)  
* email: obulygin91@ya.ru  

[Сообщество по Python](https://yandex.ru/q/loves/pythontalk/) на Кью  
[Сообщество по Data Science и анализу данных](https://yandex.ru/q/loves/datatalk/) на Кью
"""

import pandas as pd
import numpy as np

df_h = pd.read_csv('https://raw.githubusercontent.com/obulygin/pyda_homeworks/master/statistics_basics/horse_data.csv', header=None)
df_h.head()

df_h.drop(df_h.columns[[2,7,8,9,11,12,13,14,15,16,17,18,19,20,21,23,24,25,26,27]], axis = 1, inplace = True)
df_h.head()

df_h.info()

#df_h['rectal temperature'].replace('?','NaN', inplace=True)
df_h = df_h.replace('?', np.NaN)

df_h = df_h.apply(pd.to_numeric)
#astype({"0": np.Int64}) #, "2": "Int64", "3": "Int64", "4": "Int64", "5": "Int64", "10": "Int64", "22": "Int64"})

df_h.columns=['surgery?', 'Age', 'rectal temperature', 'pulse', 'respiratory rate', 'temperature of extremities', 'pain', 'outcome']

df_h.head()

df_h.info()

df_h.describe()

print('Количество значений surgery?:', df_h['surgery?'].value_counts(), sep='\n')
print('Количество значений Age:', df_h['Age'].value_counts(), sep='\n')
print('Количество значений temperature of extremities:', df_h['temperature of extremities'].value_counts(), sep='\n')
print('Количество значений pain:', df_h['pain'].value_counts(), sep='\n')
print('Количество значений outcome:', df_h['outcome'].value_counts(), sep='\n')

temperature_range = df_h['rectal temperature'].max() - df_h['rectal temperature'].min()
print('Значение размаха температуры', temperature_range)
print('Значение дисперсии температуры', np.var(df_h['rectal temperature'], ddof=1))
print('Значение медианы температуры', df_h['rectal temperature'].median())
print('Значение моды температуры: ', df_h['rectal temperature'].round().mode()[0])
print('Количество значений температуры', df_h['rectal temperature'].value_counts(), sep='\n')

pulse_range = df_h['pulse'].max() - df_h['pulse'].min()
print('Значение размаха пульса', pulse_range)
print('Значение дисперсии пульса', np.var(df_h['pulse'], ddof=1))
print('Значение медианы пульса', df_h['pulse'].median())
print('Значение моды пульса: ', df_h['pulse'].round().mode()[0])
print('Количество значений пульса', df_h['pulse'].value_counts(), sep='\n')

respiratory_rate_range = df_h['respiratory rate'].max() - df_h['respiratory rate'].min()
print('Значение размаха respiratory_rate', respiratory_rate_range)
print('Значение дисперсии respiratory_rate', np.var(df_h['respiratory rate'], ddof=1))
print('Значение медианы respiratory_rate', df_h['respiratory rate'].median())
print('Значение моды respiratory_rate: ', df_h['respiratory rate'].round().mode()[0])
print('Количество значений respiratory_rate', df_h['respiratory rate'].value_counts(), sep='\n')

q1 = df_h['rectal temperature'].quantile(0.25)
q3 = df_h['rectal temperature'].quantile(0.75)
iqr = q3 - q1
lower_bound = q1 - (1.5 * iqr)
upper_bound = q3 + (1.5 * iqr)
remove_outliers = df_h[df_h['rectal temperature'].between(lower_bound, upper_bound, inclusive=True)]
outliers = df_h[~df_h['rectal temperature'].between(lower_bound, upper_bound, inclusive=True)]
remove_outliers
#outliers

print('Количество значений respiratory_rate', df_h['respiratory rate'].value_counts(), sep='\n')

q1 = df_h['pulse'].quantile(0.25)
q3 = df_h['pulse'].quantile(0.75)
iqr = q3 - q1
lower_bound = q1 - (1.5 * iqr)
upper_bound = q3 + (1.5 * iqr)
remove_outliers = df_h[df_h['pulse'].between(lower_bound, upper_bound, inclusive=True)]
outliers = df_h[~df_h['pulse'].between(lower_bound, upper_bound, inclusive=True)]
#remove_outliers
#outliers

q1 = df_h['respiratory rate'].quantile(0.25)
q3 = df_h['respiratory rate'].quantile(0.75)
iqr = q3 - q1
lower_bound = q1 - (1.5 * iqr)
upper_bound = q3 + (1.5 * iqr)
remove_outliers = df_h[df_h['respiratory rate'].between(lower_bound, upper_bound, inclusive=True)]
outliers = df_h[~df_h['respiratory rate'].between(lower_bound, upper_bound, inclusive=True)]
#remove_outliers
outliers

print('Количество выбросов значений rectal temperature', outliers['rectal temperature'].value_counts(), sep='\n')
print('Количество выбросов значений respiratory_rate', outliers['respiratory rate'].value_counts(), sep='\n')
print('Количество выбросов значений pulse', outliers['pulse'].value_counts(), sep='\n')

df_h.info() # определяем количество пропусков

df_h['surgery?'].dropna(thresh=299).info()



print('Значение моды: ', df_h['rectal temperature'].round().mode()[0])

df = pd.read_csv('https://raw.githubusercontent.com/obulygin/netology_pyda_files/main/weight-height.csv')

# какие типы признаков в нашем датафрейме?
df.head()

# переведем в килограммы и сантиметры
df['Height'] = df['Height'] * 2.54
df['Weight'] = df['Weight'] * 0.45
df.head()

"""## Минимум, максимум и размах"""

print(max(df['Height']))
print(np.max(df['Height']))
print(df['Height'].max())

print(min(df['Weight']))
print(np.min(df['Weight']))
print(df['Weight'].min())

df[df['Weight'] == df['Weight'].min()]

# размах – разница между минимальным и максимальным значением
weight_range = df['Weight'].max() - df['Weight'].min()
height_range = df['Height'].max() - df['Height'].min()
print(weight_range)
print(height_range)

"""## Среднеарифметическое"""

# ручной подсчет
sum(df['Weight']) / len(df['Weight'])

print(np.mean(df['Weight']))
print(df['Weight'].mean())

"""## Мода"""

# Создаём пустой словарь, в котором будем считать количество появлений значений веса
weight_counts = {}
for w in df['Weight'].round():
    if w not in weight_counts:
        weight_counts[w] = 1
    else:
        weight_counts[w] += 1

# Проходимся по словарю и ищем максимальное количество повторений
# Алгоритм поиска максимума
maxw = 0
mode_weight = None
for k, v in weight_counts.items():
    if maxw < v:
        maxw = v
        mode_weight = k
print('Значение моды:', mode_weight, 'количество встречаемости:', maxw)

print('Значение моды: ', df['Weight'].round().mode()[0])



"""## Медиана"""

# ручной подсчет
height = df['Height']

# Находим  количество значений
num_height = len(df['Height'])

# Сортируем в порядке возрастания
sorted_height = sorted(height)

# Ищем индекс среднего элемента
# если количество элементов четное, то берем среднее двух элементов в середине
middle = (num_height // 2)
if num_height % 2 == 0:
    result = (sorted_height[middle-1] + sorted_height[middle])/2
else:
    result = sorted_height[middle]
# Находим медиану
print('Медиана: ', result)

print(df['Height'].median())
print(np.median(df['Height']))

"""## СКО"""

# ручной подсчет
def stdev(nums):
    diffs = 0
    # считаем среднее значение
    avg = sum(nums) / len(nums)
    for n in nums:
        # считаем сумму квадратичных отклонений
        diffs += (n - avg) ** (2)
    # считаем корень среднеквадратичного значения
    return (diffs / (len(nums) - 1)) ** (0.5)

stdev(df['Height'])

print('Рост')
print(df['Height'].std())
print(np.std(df['Height'], ddof=1)) # дельта степеней свободы в numpy по умолчанию 0

print('Вес')
print(df['Weight'].std())
print(np.std(df['Weight'], ddof=1))

"""## Дисперсия"""

# ручной подсчет
def disp(nums):
    diffs = 0
    # считаем среднее значение
    avg = sum(nums)/len(nums)
    for n in nums:
        # считаем сумму квадратичных отклонений
        diffs += (n - avg)**(2)
    # считаем среднеквадратичного значения
    return diffs/(len(nums)-1)

print(disp(df['Height']))
print(disp(df['Weight']))

print('Рост')
print(np.var(df['Height'], ddof=1))
print(df['Height'].var())

print('Вес')
print(np.var(df['Weight'], ddof=1))
print(df['Weight'].var())

"""## Квантили"""

# это же медиана!
df['Height'].quantile()

# первый и третий квартили
df['Height'].quantile([0.25, 0.75])

# произвольный перцентиль
df['Height'].quantile(0.33)

# межквартильный размах
Q1 = df['Height'].quantile(0.25)
Q3 = df['Height'].quantile(0.75)
IQR = Q3 - Q1
IQR

"""## Describe"""

df.describe()

"""## Выбросы"""

# тыкнем пальцем в небо (определим выбросы вручную) и посмотрим, как изменились средние
print(df['Weight'].mean())
print(df[(df['Weight'] > 50) & (df['Weight'] < 150)]['Weight'].mean())

# а медиана?
print(df['Weight'].median())
print(df[(df['Weight'] > 50) & (df['Weight'] < 150)]['Weight'].median())

# ну с модой все понятно
print(df['Weight'].round().mode()[0])
print(df[(df['Weight'] > 50) & (df['Weight'] < 150)]['Weight'].round().mode()[0])

"""А теперь найдем выбросы через межквартльный размах (на примере роста)

PS: через межквартильный размах корректно искать выбросы в нормально распределенных данных (про распределения будет дальше на курсе)
"""

q1 = df['Height'].quantile(0.25)
q3 = df['Height'].quantile(0.75)
iqr = q3 - q1
lower_bound = q1 - (1.5 * iqr)
upper_bound = q3 + (1.5 * iqr)
remove_outliers = df[df['Height'].between(lower_bound, upper_bound, inclusive=True)]
remove_outliers

# что это за выбросы?
df[~df['Height'].between(lower_bound, upper_bound, inclusive=True)]

print(remove_outliers['Height'].mean())
print(remove_outliers['Height'].median())

print(df['Height'].mean() - remove_outliers['Height'].mean())

print(df['Height'].median() - remove_outliers['Height'].median())

"""## Пропуски

Как часто в реальной жизни приходится заполнять пропуски?

На самом деле не часто. Заполнять нужно в том случае, когда алгоритм, для которого готовятся данные, чувствителен к пропускам. Например, регрессии и нейросети – чувствительны, а корреляция и стат-тесты нет (хотя для стат-тестов пропуски нужно удалять).

Кроме того, заполнять мы, строго говоря, имеем право только когда данные пропущены совершенно случайно (MCAR) – тогда заполнение не повлияет на характер связи междузаполняемой переменной и остальными. А то, что у нас MCAR нужно еще доказать.

Но это нужно уметь делать в тех случаях, когда необходимо.
"""

titanic = pd.read_csv('https://raw.githubusercontent.com/obulygin/netology_pyda_files/main/titanic.csv')
titanic.info()
titanic

"""Если в данных пропуски представлены в виде каких-то конкретных значений (пустые строк, -, ? и пр.), то используйте аргумент na_values при чтении файла."""

(titanic.isna().mean() * 100).round(2)

"""### Игнорирование пропусков"""

# все методы pandas по-умолчанию просто не берут в расчет пропуски
print(titanic['Age'].mean())
print(titanic['Age'].median())
print(titanic['Age'].mode()[0])

print(titanic['Age'].std())
print(titanic['Age'].var())

"""### Удаление строк с пропусками"""

titanic.dropna().info()

# посмотрите на сколько исказились статистики, если мы удалим все строки с пропусками
print(titanic.dropna()['Age'].mean())
print(titanic.dropna()['Age'].median())
print(titanic.dropna()['Age'].mode()[0])

print(titanic.dropna()['Age'].std())
print(titanic.dropna()['Age'].var())

# предположим, мы хотим оставить только те строки, в которых как минимум 11/12 значений заполнено
titanic.dropna(thresh=11).info()

"""### Удаление столбцов с пропусками"""

# удалять все в данном случае – странно
titanic.dropna(axis = 1).info()

# у нас очень много пропусков в Cabin. Нам эта информация точно нужна?
titanic.drop(['Cabin'], axis=1).info()

"""### Замена пропусков

Замена на определенное значение
"""

fill_by_cnst = titanic.copy()
fill_by_cnst['Cabin'] = fill_by_cnst['Cabin'].fillna('no_info')
print(fill_by_cnst['Cabin'].isna().sum())
print(fill_by_cnst['Cabin'].unique())

"""Заполняя пропуски, мы хотим сохранить параметры распределения заполняемой переменной – математическое ожидание и дисперсию. Самый простой способ это сделать – заполнить средним или медианой. В этом случае сохраняется среднее, но дисперсией приходится пожертвовать.

Замена средним
"""

# возраст дискретен, при заполнении средними еще стоит округлить. Проигнорируем в учебных целях

fill_mean = titanic.copy()

fill_mean['Age'] = fill_mean['Age'].fillna(titanic['Age'].mean())

print(titanic['Age'].describe())
print('-----------------------------------')
print(fill_mean['Age'].describe())

"""Замена медианой"""

fill_median = titanic.copy()

fill_median['Age'] = fill_median['Age'].fillna(titanic['Age'].median())

print(titanic['Age'].describe())
print('-----------------------------------')
print(fill_median['Age'].describe())

"""Замена модой"""

titanic['Embarked'].value_counts()

titanic_fill_mode = titanic.copy()
titanic_fill_mode['Embarked'] = titanic_fill_mode['Embarked'].fillna(titanic['Embarked'].mode()[0])

titanic_fill_mode['Embarked'].value_counts()

"""В большинстве случаев это слишком наивные варианты заполнения, как минимум стоит заполнять значениями в разрезе других признаков (когда применимо).

Заполнение пропусков с группировкой по
одной переменной
"""



# мы не можем исключать, что медианный возраст мужчин и женщин отличался
print(titanic.groupby('Sex')['Age'].median())
fill_median_by_gender = titanic.copy()
fill_median_by_gender['Age'] = fill_median_by_gender['Age'].fillna(titanic.groupby('Sex')['Age'].transform('median'))

# а может быть и в разных классах были пассажиры разного возраста?
print(titanic.groupby(['Sex', 'Pclass'])['Age'].median())
fill_median_by_groups = titanic.copy()
fill_median_by_groups['Age'] = fill_median_by_groups['Age'].fillna(titanic.groupby(['Sex', 'Pclass'])['Age'].transform('median'))



"""Заполнение следующими/предыдущими значениями"""

city_day = pd.read_csv('https://raw.githubusercontent.com/obulygin/netology_pyda_files/main/city_day.csv', parse_dates=True, index_col='Date')
city_day.info()

city_day

(city_day.isna().mean() * 100).round(2)

city_day.fillna(method='ffill', inplace=True)

city_day.fillna(method='bfill', inplace=True)

(city_day.isna().mean() * 100).round(2)